# استخدام خطوط الأنابيب لخادم ويب

إن إنشاء محرك استدلال موضوع معقد، وقد يعتمد الحل "الأفضل" على مساحة المشكلة لديك. هل أنت على وحدة المعالجة المركزية أو وحدة معالجة الرسومات؟ هل تريد أدنى حد من الكمون، أو أعلى معدل نقل، أو دعم العديد من النماذج، أو مجرد تحسين نموذج واحد محدد؟

هناك العديد من الطرق لتناول هذا الموضوع، لذا فإن ما سنقدمه هو حل افتراضي جيد للبدء، ولكنه قد لا يكون الحل الأمثل بالنسبة لك.

الشيء الرئيسي الذي يجب فهمه هو أننا يمكن أن نستخدم مؤشرًا، تمامًا كما تفعل [على مجموعة بيانات](pipeline_tutorial#using-pipelines-on-a-dataset)، نظرًا لأن خادم الويب هو أساسًا نظام ينتظر الطلبات ويعالجها عند استلامها.

عادةً ما تكون خوادم الويب متعددة الإرسال (متعددة الخيوط، غير متزامنة، إلخ) للتعامل مع الطلبات المختلفة بشكل متزامن. من ناحية أخرى، فإن خطوط الأنابيب (وبشكل أساسي النماذج الأساسية) ليست رائعة حقًا للتوازي؛ حيث تستهلك الكثير من ذاكرة الوصول العشوائي، لذا من الأفضل منحها جميع الموارد المتاحة عند تشغيلها أو أنها مهمة مكثفة الحسابات.

سنقوم بحل ذلك من خلال جعل خادم الويب يتعامل مع الحمل الخفيف لاستقبال الطلبات وإرسالها، ووجود خيط واحد يتعامل مع العمل الفعلي.

سيستخدم هذا المثال `starlette`. إطار العمل الفعلي ليس مهمًا حقًا، ولكن قد يتعين عليك ضبط الكود أو تغييره إذا كنت تستخدم إطار عمل آخر لتحقيق نفس التأثير.

أنشئ `server.py`:

الآن يمكنك تشغيله باستخدام:

```bash
uvicorn server:app
```

ويمكنك الاستعلام عنه:

```bash
curl -X POST -d "test [MASK]" http://localhost:8000/
#[{"score":0.7742936015129089,"token":1012,"token_str":".","sequence":"test."},...]
```

وهكذا، لديك الآن فكرة جيدة عن كيفية إنشاء خادم ويب!

ما هو مهم حقًا هو أننا نحمل النموذج **مرة واحدة**، لذلك لا توجد نسخ من النموذج على خادم الويب. بهذه الطريقة، لا يتم استخدام ذاكرة الوصول العشوائي غير الضرورية.

بعد ذلك، تسمح آلية وضع الطابور بالقيام بأشياء رائعة مثل ربما تجميع بعض العناصر قبل الاستدلال لاستخدام الدفعات الديناميكية:

إن عينة الكود أدناه مكتوبة بشكل مقصود مثل كود وهمي للقراءة. لا تقم بتشغيله دون التحقق مما إذا كان منطقيًا لموارد النظام الخاص بك!

مرة أخرى، الكود المقترح يتم تحسينه للقراءة، وليس ليكون أفضل كود.

أولاً، لا يوجد حد لحجم الدفعة، وهو ما لا يعد فكرة رائعة بشكل عام. بعد ذلك، يتم إعادة تعيين المهلة في كل عملية استرداد للصف، مما يعني أنه قد يتعين عليك الانتظار لفترة أطول بكثير من 1 مللي ثانية قبل تشغيل الاستدلال (تأخير الطلب الأول بذلك القدر).

سيكون من الأفضل وجود موعد نهائي واحد لمدة 1 مللي ثانية.

سيؤدي هذا دائمًا إلى الانتظار لمدة 1 مللي ثانية حتى إذا كان الطابور فارغًا، وهو ما قد لا يكون الأفضل نظرًا لأنك تريد على الأرجح البدء في إجراء الاستدلال إذا لم يكن هناك شيء في الطابور.

ولكن ربما يكون منطقيًا إذا كانت الدفعات مهمة حقًا لحالتك الاستخدام.

مرة أخرى، لا يوجد حل واحد الأفضل.

## بعض الأشياء التي قد ترغب في مراعاتها

### التحقق من الأخطاء

هناك الكثير مما يمكن أن يسير على ما يرام في الإنتاج: نفاد الذاكرة، أو امتلاء المساحة، أو فشل تحميل النموذج، أو الخطأ في الاستعلام، أو الاستعلام الصحيح ولكنه لا يزال يفشل في التشغيل بسبب سوء تهيئة النموذج، وهكذا.

بشكل عام، من الجيد أن يقوم الخادم بإخراج الأخطاء إلى المستخدم، لذا فإن إضافة الكثير من عبارات `try..except` لعرض هذه الأخطاء فكرة جيدة. ولكن ضع في اعتبارك أنه قد يكون أيضًا خطرًا أمنيًا للكشف عن جميع هذه الأخطاء اعتمادًا على سياق الأمان الخاص بك.

### كسر الدائرة

عادةً ما تبدو خوادم الويب أفضل عندما تقوم بكسر الدائرة. وهذا يعني أنها تعيد أخطاء صحيحة عندما تكون مثقلة بالأعباء بدلاً من الانتظار للاستعلام لفترة طويلة من الزمن. قم بإرجاع خطأ 503 بدلاً من الانتظار لفترة طويلة جدًا أو خطأ 504 بعد فترة طويلة.

من السهل نسبيًا تنفيذ ذلك في الكود المقترح نظرًا لوجود طابور واحد.

إن النظر في حجم الطابور هو طريقة أساسية لبدء إعادة الأخطاء قبل فشل خادم الويب تحت الحمل.

### حظر الخيط الرئيسي

حاليًا، PyTorch غير مدرك للأساليب غير المتزامنة، وسيؤدي الحساب إلى حظر الخيط الرئيسي أثناء تشغيله. وهذا يعني أنه سيكون من الأفضل إذا تم إجبار PyTorch على التشغيل على خيط/عملية خاصة به. لم يتم ذلك هنا لأن الكود أكثر تعقيدًا (غالبًا لأن الخيوط والأساليب غير المتزامنة وطوابير الانتظار لا تعمل بشكل جيد معًا).

ولكن في النهاية، فإنه يؤدي نفس الشيء.

سيكون هذا مهمًا إذا كان الاستدلال للعناصر الفردية طويلًا (> 1 ثانية) لأنه في هذه الحالة، يجب أن ينتظر كل استعلام أثناء الاستدلال لمدة 1 ثانية قبل حتى تلقي خطأ.

### الدفعات الديناميكية

بشكل عام، لا تعد الدفعات بالضرورة تحسينًا عن تمرير عنصر واحد في كل مرة (راجع [تفاصيل الدفعات](./main_classes/pipelines#pipeline-batching) لمزيد من المعلومات). ولكن يمكن أن يكون فعالًا للغاية عند استخدامه في الإعداد الصحيح. في واجهة برمجة التطبيقات، لا توجد دفعات ديناميكية بشكل افتراضي (الكثير من الفرص لتباطؤ). ولكن بالنسبة لاستدلال BLOOM - وهو نموذج كبير جدًا - فإن الدفعات الديناميكية **ضرورية** لتوفير تجربة جيدة للجميع.