# فهم الأنابيب والنماذج وجداول المواعيد 

صُممت أدوات النشر لتكون صندوق أدوات سهل الاستخدام ومرنًا لإنشاء أنظمة نشر مخصصة لحالتك الاستخدامية. النماذج وجداول المواعيد هي جوهر صندوق الأدوات. في حين أن [DiffusionPipeline] تجمع هذه المكونات معًا للراحة، يمكنك أيضًا إلغاء حزم الأنبوب واستخدام النماذج وجداول المواعيد بشكل منفصل لإنشاء أنظمة نشر جديدة.

في هذا البرنامج التعليمي، ستتعلم كيفية استخدام النماذج وجداول المواعيد لتجميع نظام نشر للاستدلال، بدءًا من خط أنابيب أساسي ثم الانتقال إلى خط أنابيب النشر المستقر.

## فك خط أنابيب أساسي

خط الأنابيب هو طريقة سريعة وسهلة لتشغيل نموذج للاستدلال، ولا يتطلب أكثر من أربعة أسطر من التعليمات البرمجية لتوليد صورة:

في المثال أعلاه، يحتوي خط الأنابيب على نموذج [UNet2DModel] وجدول مواعيد [DDPMScheduler]. يقوم خط الأنابيب بإزالة ضوضاء الصورة عن طريق أخذ ضوضاء عشوائية بحجم الإخراج المطلوب ومروره عبر النموذج عدة مرات. في كل خطوة زمنية، يتنبأ النموذج ب *بقايا الضوضاء* ويستخدمها الجدول الزمني للتنبؤ بصورة أقل ضوضاءً. يكرر خط الأنابيب هذه العملية حتى يصل إلى نهاية عدد خطوات الاستدلال المحددة.

لإعادة إنشاء خط الأنابيب باستخدام النموذج وجدول المواعيد بشكل منفصل، دعنا نكتب عملية إزالة الضوضاء الخاصة بنا.

1. قم بتحميل النموذج وجدول المواعيد:

```py
>>> من الناشرين استيراد DDPMScheduler، UNet2DModel

>>> جدول المواعيد = DDPMScheduler.from_pretrained ("google/ddpm-cat-256")
>>> model = UNet2DModel.from_pretrained ("google/ddpm-cat-256", use_safetensors = True).to ("cuda")
```

2. قم بتعيين عدد الخطوات الزمنية لتشغيل عملية إزالة الضوضاء:

```py
>>> جدول المواعيد. set_timesteps (50)
```

3. يؤدي تعيين خطوات جدول المواعيد إلى إنشاء مصفوفة ذات عناصر متباعدة بالتساوي فيها، 50 في هذا المثال. يرتبط كل عنصر بخطوة زمنية يقوم فيها النموذج بإزالة ضوضاء الصورة. عندما تقوم بإنشاء حلقة إزالة الضوضاء لاحقًا، فستقوم بالتعيين فوق هذه المصفوفة لإزالة ضوضاء الصورة:

```py
>>> جدول المواعيد. المواعيد الزمنية
مصفوفة ([980، 960، 940، 920، 900، 880، 860، 840، 820، 800، 780، 760، 740، 720،
700، 680، 660، 640، 620، 600، 580، 560، 540، 520، 500، 480، 460، 440،
420، 400، 380، 360، 340، 320، 300، 280، 260، 240، 220، 200، 180، 160،
140، 120، 100، 80، 60، 40، 20، 0])
```

4. قم بإنشاء بعض الضوضاء العشوائية بنفس شكل الإخراج المطلوب:

```py
>>> استيراد الشعلة

>>> حجم العينة = model.config.sample_size
>>> الضوضاء = الشعلة. randn ((1، 3، حجم العينة، حجم العينة)، الجهاز = "cuda")
```

5. الآن اكتب حلقة للتعيين فوق الخطوات الزمنية. في كل خطوة زمنية، يقوم النموذج بتنفيذ تمريرة [UNet2DModel.forward] ويعيد بقايا الضوضاء. تستخدم طريقة [~ DDPMScheduler.step] الخاصة بجدول المواعيد بقايا الضوضاء والخطوة الزمنية والإدخال للتنبؤ بالصورة في الخطوة الزمنية السابقة. يصبح هذا الإخراج الإدخال التالي للنموذج في حلقة إزالة الضوضاء، وسوف يتكرر حتى يصل إلى نهاية صفيف "الخطوات الزمنية".

```py
>>> الإدخال = الضوضاء

>>> لكل t في جدول المواعيد. المواعيد الزمنية:
... مع الشعلة. لا_grad ():
... بقايا الضوضاء المتنقلة = model (input، t). sample
... العينة الضوضاء السابقة = جدول المواعيد. step (noisy_residual، t، input). prev_sample
... الإدخال = العينة الضوضاء السابقة
```

هذه هي عملية إزالة الضوضاء بأكملها، ويمكنك استخدام هذا النمط نفسه لكتابة أي نظام نشر.

6. الخطوة الأخيرة هي تحويل الإخراج الخالي من الضوضاء إلى صورة:

```py
>>> من صورة PIL استيراد الصورة
>>> استيراد numpy كما np

>>> الصورة = (الإدخال / 2 + 0.5). clamp (0، 1). squeeze ()
>>> الصورة = (الصورة. permute (1، 2، 0) * 255). round (). to (torch.uint8). cpu (). numpy ()
>>> الصورة = Image.fromarray (الصورة)
>>> الصورة
```

في القسم التالي، ستختبر مهاراتك عن طريق تفكيك خط أنابيب نشر مستقر أكثر تعقيدًا. الخطوات هي نفسها تقريبًا. ستقوم بتهيئة المكونات اللازمة، وتعيين عدد الخطوات الزمنية لإنشاء صفيف "الخطوات الزمنية". يتم استخدام صفيف "الخطوات الزمنية" في حلقة إزالة الضوضاء، وفي كل عنصر من هذا الصفيف، يتنبأ النموذج بصورة أقل ضوضاءً. تتعيين الحلقة الخالية من الضوضاء فوق "الخطوات الزمنية"، وفي كل خطوة زمنية، تقوم بإخراج بقايا الضوضاء ويستخدمها الجدول الزمني للتنبؤ بصورة أقل ضوضاءً في الخطوة الزمنية السابقة. تتكرر هذه العملية حتى تصل إلى نهاية صفيف "الخطوات الزمنية".

دعنا نجرب ذلك!

## فك خط أنابيب النشر المستقر

النشر المستقر هو نموذج نشر نصي إلى صورة *نشر خفي*. يطلق عليه نموذج نشر خفي لأنه يعمل مع تمثيل منخفض الأبعاد للصورة بدلاً من مساحة البكسل الفعلية، مما يجعله أكثر كفاءة في الذاكرة. يقوم المشفر بضغط الصورة إلى تمثيل أصغر، ويتم استخدام فك تشفير لتحويل التمثيل المضغوط مرة أخرى إلى صورة. بالنسبة لنماذج النص إلى الصورة، ستحتاج إلى محدد موضعي ومشفر لإنشاء تضمينات نصية. من المثال السابق، أنت تعرف بالفعل أنك بحاجة إلى نموذج UNet وجدول مواعيد.

كما ترون، هذا أكثر تعقيدًا بالفعل من خط أنابيب DDPM الذي يحتوي فقط على نموذج UNet. يحتوي نموذج النشر المستقر على ثلاثة نماذج مسبقة التدريب منفصلة.

💡 اقرأ المدونة [كيف يعمل النشر المستقر؟](Https://huggingface.co/blog/stable_diffusion#how-does-stable-diffusion-work) لمزيد من التفاصيل حول كيفية عمل نماذج VAE و UNet ومشفر النص.

الآن بعد أن عرفت ما تحتاجه لخط أنابيب النشر المستقر، قم بتحميل جميع هذه المكونات باستخدام طريقة [~ ModelMixin.from_pretrained]. يمكنك العثور عليها في نقطة التحقق المسبقة التدريب [runwayml/stable-diffusion-v1-5] (https://huggingface.co/runwayml/stable-diffusion-v1-5)، ويتم تخزين كل مكون في مجلد فرعي منفصل:

```py
>>> من صورة PIL استيراد الصورة
>>> استيراد الشعلة
>>> من المحولات استيراد CLIPTextModel، CLIPTokenizer
>>> من الناشرين استيراد AutoencoderKL، UNet2DConditionModel، PNDMScheduler

>>> فاي = AutoencoderKL.from_pretrained ("CompVis/stable-diffusion-v1-4"، subfolder = "vae"، use_safetensors = True)
>>> محدد المواضع = CLIPTokenizer.from_pretrained ("CompVis/stable-diffusion-v1-4"، subfolder = "محلل")
>>> مشفر النص = CLIPTextModel.from_pretrained (
... "CompVis/stable-diffusion-v1-4"، subfolder = "text_encoder"، use_safetensors = True
... )
>>> unet = UNet2DConditionModel.from_pretrained (
... "CompVis/stable-diffusion-v1-4"، subfolder = "unet"، use_safetensors = True
... )
```

بدلاً من جدول المواعيد [PNDMScheduler] الافتراضي، استبدله بجدول المواعيد [UniPCMultistepScheduler] لمعرفة مدى سهولة توصيل جدول مواعيد مختلف:

```py
>>> من الناشرين استيراد UniPCMultistepScheduler

>>> جدول المواعيد = UniPCMultistepScheduler.from_pretrained ("CompVis/stable-diffusion-v1-4"، subfolder = "جدول المواعيد")
```

للإسراع في الاستدلال، قم بنقل النماذج إلى وحدة معالجة الرسومات (GPU) نظرًا لوجود أوزان قابلة للتدريب، على عكس جدول المواعيد:

```py
>>> جهاز الشعلة = "cuda"
>>> فاي. إلى (جهاز الشعلة)
>>> مشفر النص. إلى (جهاز الشعلة)
>>> unet. إلى (جهاز الشعلة)
```

### إنشاء تضمينات نصية

الخطوة التالية هي توكينيز النص لتوليد التضمينات. يتم استخدام النص لتكييف نموذج UNet وتوجيه عملية النشر نحو شيء يشبه موجه النص.

💡 يحدد معلمة "مقياس التوجيه" مقدار الوزن الذي يجب منحه للموجه عند إنشاء صورة.

لا تتردد في اختيار أي موجه تريده إذا كنت تريد إنشاء شيء آخر!

```py
>>> موجه = ["صورة فوتوغرافية لرائد فضاء يركب حصانًا"]
>>> الارتفاع = 512 # ارتفاع النشر المستقر الافتراضي
>>> العرض = 512 # عرض النشر المستقر الافتراضي
>>> عدد خطوات الاستدلال = 25 # عدد خطوات إزالة الضوضاء
>>> مقياس التوجيه = 7.5 # مقياس التوجيه خالي من التصنيف
>>> المولد = الشعلة. seed () # Seed generator لإنشاء الضوضاء الأولية
>>> حجم الدفعة = len (prompt)
```

قم بتوكينيز النص وإنشاء التضمينات من الموجه:

```py
>>> نص الإدخال = محدد المواضع (
... موجه، وسادة = "طول أقصى"، طول أقصى = محدد المواضع. model_max_length، truncation = True، return_tensors = "pt"
... )

>>> مع الشعلة. لا_grad ():
... التضمينات النصية = مشفر النص (نص الإدخال. input_ids.to (جهاز الشعلة)) [0]
```

ستحتاج أيضًا إلى إنشاء *تضمينات النص غير المشروطة* والتي تكون التضمينات الخاصة برمز الحشو. يجب أن يكون لهذه الأبعاد نفسها ("حجم الدفعة" و "طول التسلسل") مثل التضمينات المشروطة:

```py
>>> الطول الأقصى = نص الإدخال. شكل input_ids [-1]
>>> إدخال غير مشروط = محدد المواضع ([""] * حجم الدفعة، وسادة = "طول أقصى"، طول أقصى = الطول الأقصى، return_tensors = "pt")
>>> التضمينات غير المشروطة = مشفر النص (إدخال غير مشروط. input_ids.to (جهاز الشعلة)) [0]
```

دعنا نقوم بدمج التضمينات المشروطة وغير المشروطة في دفعة لتجنب إجراء تمريرين:

```py
>>> التضمينات النصية = الشعلة. cat ([التضمينات غير المشروطة، التضمينات النصية])
```
### إنشاء ضوضاء عشوائية

بعد ذلك، قم بتوليد بعض الضوضاء العشوائية الأولية كنقطة بداية لعملية الانتشار. هذا هو التمثيل الكامن للصورة، وسيتم إزالة تشويشه تدريجيًا. في هذه المرحلة، تكون الصورة الكامنة أصغر من حجم الصورة النهائي، ولكن هذا أمر طبيعي لأن النموذج سيحولها لاحقًا إلى أبعاد الصورة النهائية 512x512.

<Tip>

💡 يتم تقسيم الارتفاع والعرض على 8 لأن نموذج "vae" لديه 3 طبقات لتخفيض العينات. يمكنك التحقق من ذلك عن طريق تشغيل ما يلي:

2 ** (len(vae.config.block_out_channels) - 1) == 8

</Tip>

```py
>>> latents = torch.randn(
...     (batch_size, unet.config.in_channels, height // 8, width // 8),
...     generator=generator,
...     device=torch_device,
... )
```

### إزالة تشويش الصورة

ابدأ بتحجيم الإدخال مع توزيع الضوضاء الأولية، *sigma*، وقيمة مقياس الضوضاء، والتي تكون مطلوبة لمخططات التحسين المحسّنة مثل [`UniPCMultistepScheduler`]:

```py
>>> latents = latents * scheduler.init_noise_sigma
```

الخطوة الأخيرة هي إنشاء حلقة إزالة التشويش التي ستحول الضوضاء البحتة في "latents" إلى صورة موصوفة بواسطة موجهك تدريجيًا. تذكر، تحتاج حلقة إزالة التشويش إلى القيام بثلاثة أشياء:

1. قم بتعيين خطوات الوقت التي يستخدمها المخطط أثناء إزالة التشويش.
2. قم بالتعيين على خطوات الوقت.
3. في كل خطوة زمنية، قم بالاتصال بنموذج UNet للتنبؤ ببقايا الضوضاء ومررها إلى المخطط لحساب العينة المشوشة السابقة.

```py
>>> from tqdm.auto import tqdm

>>> scheduler.set_timesteps(num_inference_steps)

>>> for t in tqdm(scheduler.timesteps):
...     # قم بتوسيع latents إذا كنا نقوم بالإرشاد الخالي من التصنيف لتجنب إجراء تمريرين للأمام.
...     latent_model_input = torch.cat([latents] * 2)

...     latent_model_input = scheduler.scale_model_input(latent_model_input, timestep=t)

...     # التنبؤ ببقايا الضوضاء
...     مع torch.no_grad():
...         noise_pred = unet(latent_model_input, t, encoder_hidden_states=text_embeddings).sample

...     # أداء الإرشاد
...     noise_pred_uncond, noise_pred_text = noise_pred.chunk(2)
...     noise_pred = noise_pred_uncond + guidance_scale * (noise_pred_text - noise_pred_uncond)

...     # احسب العينة المشوشة السابقة x_t -> x_t-1
...     latents = scheduler.step(noise_pred، t، latents).prev_sample
```

### فك تشفير الصورة

الخطوة الأخيرة هي استخدام "vae" لترميز التمثيل الكامن في صورة والحصول على الإخراج المشفر باستخدام "sample":

```py
# تحجيم وفك تشفير صورة latents باستخدام vae
latents = 1 / 0.18215 * latents
مع torch.no_grad():
image = vae.decode(latents).sample
```

أخيرًا، قم بتحويل الصورة إلى `PIL.Image` لمشاهدة الصورة التي تم إنشاؤها!

```py
>>> image = (image / 2 + 0.5).clamp(0, 1).squeeze()
>>> image = (image.permute(1, 2, 0) * 255).to(torch.uint8).cpu().numpy()
>>> image = Image.fromarray(image)
>>> image
```

<div class="flex justify-center">
<img src="https://huggingface.co/blog/assets/98_stable_diffusion/stable_diffusion_k_lms.png"/>
</div>

## الخطوات التالية

من الأنابيب الأساسية إلى المعقدة، رأيت أن كل ما تحتاجه حقًا لكتابة نظام انتشار خاص بك هو حلقة إزالة التشويش. يجب أن تقوم الحلقة بتعيين خطوات الوقت للمخطط، والتعيين عليها، والتبديل بين استدعاء نموذج UNet للتنبؤ ببقايا الضوضاء ومروره إلى المخطط لحساب العينة المشوشة السابقة.

هذا هو الغرض الحقيقي من 🧨 Diffusers: جعلها بديهية وسهلة لكتابة نظام انتشار خاص بك باستخدام النماذج والمخططات.

في الخطوات التالية، لا تتردد في:

* تعلم كيفية [بناء والمساهمة في خط أنابيب](../using-diffusers/contribute_pipeline) إلى 🧨 Diffusers. لا يمكننا الانتظار ورؤية ما سوف تأتي به!
* استكشاف [خطوط الأنابيب الموجودة](../api/pipelines/overview) في المكتبة، وانظر ما إذا كان بإمكانك تفكيك وبناء خط أنابيب من الصفر باستخدام النماذج والمخططات بشكل منفصل.